// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: borrows.sql

package dbstore

import (
	"context"
	"time"
)

const bookBorrow = `-- name: BookBorrow :many
INSERT INTO bookBorrows (borrowDate,returnDate,user_id,book_id,status) 
VALUES ($1, $2, $3,$4,$5) RETURNING id, borrowdate, returndate, user_id, book_id, status
`

type BookBorrowParams struct {
	Borrowdate time.Time `json:"borrowdate"`
	Returndate time.Time `json:"returndate"`
	UserID     int64     `json:"user_id"`
	BookID     int64     `json:"book_id"`
	Status     string    `json:"status"`
}

func (q *Queries) BookBorrow(ctx context.Context, arg BookBorrowParams) ([]Bookborrow, error) {
	rows, err := q.db.QueryContext(ctx, bookBorrow,
		arg.Borrowdate,
		arg.Returndate,
		arg.UserID,
		arg.BookID,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bookborrow
	for rows.Next() {
		var i Bookborrow
		if err := rows.Scan(
			&i.ID,
			&i.Borrowdate,
			&i.Returndate,
			&i.UserID,
			&i.BookID,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrowHistory = `-- name: GetBorrowHistory :many
SELECT
    bb.id AS borrow_id,
    bb.borrowDate,
    bb.returnDate,
    bb.status,
    u.username AS user_username,
    b.name AS book_name
FROM
    bookBorrows bb
INNER JOIN
    users u ON bb.user_id = u.id
INNER JOIN
    books b ON bb.book_id = b.id
`

type GetBorrowHistoryRow struct {
	BorrowID     int64     `json:"borrow_id"`
	Borrowdate   time.Time `json:"borrowdate"`
	Returndate   time.Time `json:"returndate"`
	Status       string    `json:"status"`
	UserUsername string    `json:"user_username"`
	BookName     string    `json:"book_name"`
}

func (q *Queries) GetBorrowHistory(ctx context.Context) ([]GetBorrowHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getBorrowHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBorrowHistoryRow
	for rows.Next() {
		var i GetBorrowHistoryRow
		if err := rows.Scan(
			&i.BorrowID,
			&i.Borrowdate,
			&i.Returndate,
			&i.Status,
			&i.UserUsername,
			&i.BookName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBorrows = `-- name: GetBorrows :many
SELECT
    bb.id AS borrow_id,
    bb.borrowDate,
    bb.returnDate,
    bb.status,
    u.username AS user_username,
    b.name AS book_name
FROM
    bookBorrows bb
INNER JOIN
    users u ON bb.user_id = u.id
INNER JOIN
    books b ON bb.book_id = b.id
WHERE status= $1 OR bb.returnDate < CURRENT_TIMESTAMP
`

type GetBorrowsRow struct {
	BorrowID     int64     `json:"borrow_id"`
	Borrowdate   time.Time `json:"borrowdate"`
	Returndate   time.Time `json:"returndate"`
	Status       string    `json:"status"`
	UserUsername string    `json:"user_username"`
	BookName     string    `json:"book_name"`
}

func (q *Queries) GetBorrows(ctx context.Context, status string) ([]GetBorrowsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBorrows, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBorrowsRow
	for rows.Next() {
		var i GetBorrowsRow
		if err := rows.Scan(
			&i.BorrowID,
			&i.Borrowdate,
			&i.Returndate,
			&i.Status,
			&i.UserUsername,
			&i.BookName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const returnbook = `-- name: Returnbook :exec
UPDATE bookBorrows
  set status = $2
WHERE id = $1
`

type ReturnbookParams struct {
	ID     int64  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) Returnbook(ctx context.Context, arg ReturnbookParams) error {
	_, err := q.db.ExecContext(ctx, returnbook, arg.ID, arg.Status)
	return err
}
